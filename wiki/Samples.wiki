#summary Describes the samples

1. [http://code.google.com/p/cppao/source/browse/trunk/samples/hello_active.cpp]

This sample prints "Hello, world!". Demonstrates:

  * Defining a basic AO with one active method.
  * Implementing an active method in a class.
  * Passing a message to an active object with a payload.
  * Running an AO in a single thread.

2. [http://code.google.com/p/cppao/source/browse/trunk/samples/ping_pong.cpp]

This sample displays ping/pong ten times. Demonstrates:

  * Defining an AO with more than one message handler.
 
3. [http://code.google.com/p/cppao/source/browse/trunk/samples/round_robin.cpp]

Demonstrates:

  * Multiple instances of the same class (active class?)
  * Running multiple objects concurrently using _active::run()_

4. [http://code.google.com/p/cppao/source/browse/trunk/samples/bench.cpp]

This is a simple (and not really very good) benchmark of multi-threaded performance, from the infamous computer language shootout. [http://shootout.alioth.debian.org/] This is the "thread-ring" benchmark which passes a token around 503 threads. [http://shootout.alioth.debian.org/u32/performance.php?test=threadring]

Demonstrates:

  * A performance metric.

5. [http://code.google.com/p/cppao/source/browse/trunk/samples/return_result.cpp]

This sample performs a simple computation, and puts the result of the computation somewhere. However this approach is not a good one because you are mixing paradigms, there is no synchronization, and shared state is generally against what AO are all about.

Demonstrates:

  * Returning results using some kind of shared state.

6. [http://code.google.com/p/cppao/source/browse/trunk/samples/future.cpp]

This sample performs a simple computation, then uses a future to hold the result. This is much better because there is now synchronization, and is also the "traditional" solution to how AOs return results.

Demonstrates:

  * Returning results in a promise.

7. [http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result.cpp]

This sample performs a computation, and then notifies another object of the result. This is much better because the solution is much more consistent and pure (using just one technology), however the computation is now coupled to the result recipient which is not good.

Demonstrates: 

  * Passing the result of a computation to another AO.

8. [http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result_iface.cpp]

Performs a computation, then passes the result to another object. Unlike the previous example however, a virtual base class is used to decouple the sender from the recipient.

Demonstrates:

  * ACTIVE_IFACE macro
  * How to implement interfaces for AOs.

9. [http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result_sink.cpp]

This passes the result of a computation to another AO via an interface as before, but this time the interfaces is provided by the _active::sink&lt;&gt;_ class. (Note a class can inherit from multiple _active::sink&lt;&gt;_ classes if it receives results from multiple places).

Demonstrates:

  * active::sink&lt;&gt;
  * How to pass messages between objects in a more abstract way.

10. Life
[http://code.google.com/p/cppao/source/browse/trunk/samples/life.hpp]
[http://code.google.com/p/cppao/source/browse/trunk/samples/life.cpp]

Implements Conway's "Game of Life" to a console.  Demonstrates:

  * Multiple classes with multiple message types.
  * A more complex example.
  * Using ACTIVE_IMPL to separate method declarations from definitions.

11. Active sockets
http://code.google.com/p/cppao/source/browse/trunk/samples/active_socket.hpp
http://code.google.com/p/cppao/source/browse/trunk/samples/active_socket.cpp

12. Echo
http://code.google.com/p/cppao/source/browse/trunk/samples/echo.cpp
http://code.google.com/p/cppao/source/browse/trunk/samples/echo_server.cpp
http://code.google.com/p/cppao/source/browse/trunk/samples/echo_client.cpp