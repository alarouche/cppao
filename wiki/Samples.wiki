#summary Describes the samples

=Hello world!=
[http://code.google.com/p/cppao/source/browse/trunk/samples/hello_active.cpp]

A text message is sent to an active object (AO), which displays it.  Demonstrates:

  * Defining a basic AO with one active method.
  * Implementing an active method in a class.
  * Passing a message to an active object with a payload.
  * Running an AO in a single thread.

=Ping pong=
[http://code.google.com/p/cppao/source/browse/trunk/samples/ping_pong.cpp]

A message is sent backwards and forwards between two active methods (message handlers) in the same AO. Demonstrates:

  * Defining an AO with more than one message handler.
 
=Round robin=
[http://code.google.com/p/cppao/source/browse/trunk/samples/round_robin.cpp]

A message is sent to each of 1000 nodes, which then pass the message onwards to the next node in the loop, with a time-to-live of 10 hops for each message. Demonstrates:

  * Multiple instances of the same class (active class?)
  * Fixed topology/connections between AOs.
  * Running multiple objects concurrently using _active::run()_

=Thread-ring=
[http://code.google.com/p/cppao/source/browse/trunk/samples/bench.cpp]

This is a simple (and not really very good) benchmark of multi-threaded performance, from the infamous computer language shootout. [http://shootout.alioth.debian.org/] This is the "thread-ring" benchmark which passes a token around 503 threads. [http://shootout.alioth.debian.org/u32/performance.php?test=threadring]

Demonstrates:

  * A performance metric.
  * Compares the performance of different AO implementations.
  * Use of _active::object_impl<>_ to tune the underlying implementation.


=Forward results=
[http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result.cpp]

A message is passed to an AO containing the parameters for a computation, and a pointer to an AO which will receive the result of the computation.

Demonstrates: 

  * Passing the result of a computation to another AO.
  * Separating declaration and definition using `ACTIVE_IMPL`,
  * `const` active methods.

=Interfaces=
[http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result_iface.cpp]

A message is passed to an AO, containing the parameters for a computation, and a pointer to an interface which receives the result. Unlike the previous example however, a virtual base class is used to decouple the sender from the recipient.

Demonstrates:

  * `ACTIVE_IFACE` macro,
  * How to implement interfaces for AOs.

=Message sinks=
[http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result_sink.cpp]

An interface to an AO is defined using the `active::sink<>` class. The result of a computation is passed to an AO of type `active::sink<>`. Seems to be the most elegant way to connect objects.

Demonstrates:

  * `active::sink<>`,
  * How to pass messages between objects in a more abstract way.

=Promises promises=
[http://code.google.com/p/cppao/source/browse/trunk/samples/future.cpp]

A message is passed to an AO, containing parameters for a computation, and a pointer to a promise where the result should be stored. When the computation is complete, the promise is fulfilled.

This is close to the "traditional" solution to how AOs return results.

Demonstrates:

  * Returning results in a promise.

=Queue control=
[http://code.google.com/p/cppao/source/browse/trunk/samples/queue_control.cpp]

Sends a high priority shutdown message to an AO to clear its pending message queue.

Demonstrates:
  * The `active::advanced` object type.
  * Prioritising messages.
  * Clearing the message queue.

=Exceptions=
[http://code.google.com/p/cppao/source/browse/trunk/samples/exception.cpp]

An active method throws an exception which calls an exception handler.

Demonstrates:

  * How to catch exceptions,
  * `exception_handler()`

= Prime number sieve =
[http://code.google.com/p/cppao/source/browse/trunk/samples/sieve.cpp]
[http://code.google.com/p/cppao/source/browse/trunk/samples/sieve2.cpp]

Outputs the list of prime numbers. Creates a list of AOs which are used to filter a sequence of integers.

The second program improves upon the first by handling longer lists (>1000000), since there is a "bug" in `std::shared_ptr<>` in that it cannot represent very long linked lists without the destructor running out of stack space.

Demonstrates:

  * `active::shared<>`,
  * Dynamic creation of AOs.

=Game of life=
[http://code.google.com/p/cppao/source/browse/trunk/samples/life.hpp]
[http://code.google.com/p/cppao/source/browse/trunk/samples/life.cpp]

Implements Conway's "Game of Life" in a console.  Each cell is its own AO, in addition to a controller and a display AO. All communication between AOs is via message passing. This is an exercise in synchronisation (all cells must update synchronously) and message flows.

Demonstrates:

  * Multiple classes with multiple message types.
  * A more complex example.
  * Using `ACTIVE_IMPL` to separate method declarations from definitions.
  * `active::scheduler`

= Object types =
http://code.google.com/p/cppao/source/browse/trunk/samples/object_types.cpp

Creates and runs eight different AO implementations. Demonstrates:

  * How to use different object types,
  * Different characteristics of different objects,
  * How to use shared objects for additional safety.

= Fibonacci =
[http://code.google.com/p/cppao/source/browse/trunk/samples/fib.cpp]

Implements a deliberately naive recursive Fibonacci number calculator (F(n)=F(n-1)+F(n-2)), where each number spawns two active objects - resulting in an exponential increase in the number of AOs.

Demonstrates:

  * Dynamic creation of AOs.
  * A benchmark.
  * Fire-and-forget AOs, which are destroyed automatically.
  * `active::shared`
  * The fact that for trivial calculations, the `direct` object type can be best.

=Active sockets=
[http://code.google.com/p/cppao/source/browse/trunk/samples/active_socket.hpp]
[http://code.google.com/p/cppao/source/browse/trunk/samples/active_socket.cpp]

Wrapping a synchronous object inside an AO. Many POSIX/Winsock functions are provided, but as messages.

Demonstrates:

  * Use of `std::shared_ptr` to contain objects,
  * `active::shared<>`,
  * Composite objects: `socket` contains a `reader` and a `writer`; `select` contains a `select_loop`,
  * Network programming.

=Echo=
[http://code.google.com/p/cppao/source/browse/trunk/samples/echo.cpp]

A simple command line utility which copies text from input to output using the socket AO, as well as a special "pipe" AO which copies data between two file descriptors.

Demonstrates:

  * Tests the socket object.

=Echo client/server=
[http://code.google.com/p/cppao/source/browse/trunk/samples/echo_server.cpp]
[http://code.google.com/p/cppao/source/browse/trunk/samples/echo_client.cpp]

Building on the socket and pipe objects, we construct a TCP/IP client/server. The echo_server simply echos data which is sent to it, and the echo_client forwards input to the server, reads the response then outputs it. The echo_client can bounce data between the client and the server a specified number of times.

Demonstrates:

  * Asynchronous IO,
  * Writing network applications,
  * Concurrent socket operations,
  * Multiple message sinks on the same object.

=Mandelbrot=
[http://code.google.com/p/cppao/source/browse/trunk/samples/mandelbrot.hpp]
[http://code.google.com/p/cppao/source/browse/trunk/samples/mandelbrot.cpp]

An interactive viewer of the Mandelbrot fractal. The screen is divided into 256 segments which are computed in independent active objects.

Demonstrates:
  * Dividing large problems.
  * Array processing.
  * Passing large arrays using move semantics.
  * Integrating with a GUI.
  * Running concurrently with a GUI message loop.
  * Using `active::run` as a scoped object not a function.