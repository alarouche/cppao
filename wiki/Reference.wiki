#summary Detailed description of cppao.

= Header =
{{{
#include <active_object.hpp>
}}}

= Namespace =
All declarations are in the namespace `active`.
= Classes =
== active::object_impl ==

{{{
template<typename Schedule, typename Queueing, typename Sharing> struct object_impl;
}}}

Types:

|| `queue_type` || `Queueing` ||
|| `schedule_type` || `Schedule` ||
|| `sharing_type` || `Sharing` ||
|| `scheduler_type` || Usually `active::scheduler` ||
|| `allocator_type` || `Queueing::allocator_type` ||

Methods:

|| `object_impl(scheduler_type & p = default_scheduler, const allocator_type & alloc = allocator_type())` || Default constructor. Objects are scheduled by the global `default_scheduler` unless otherwise specified. ||
|| `object_impl(const object_impl&)` || Does a default copy, but does not copy any messages. ||
|| `object_impl & operator=(const object_impl&)` || Default copy operator, but does not copy any messages. ||
|| `~object_impl()` || Destroys the object; must not be called whilst there are unprocessed messages. ||
|| `void set_scheduler(scheduler_type & p)` || Change the scheduler. Must not be called after messages have been sent to the object. ||
|| `virtual void exception_handler()` || Called when an exception escapes from a message handler. This must not throw an exception. The default implementation is to write a message and continue, but can be overridden. ||
|| `allocator_type get_allocator() const` || Returns a copy of the allocator passed into the constructor. ||
|| `void operator()(const Msg&)` || Message handlers defined by `ACTIVE_IFACE` and `ACTIVE_METHOD` macros. This might throw an exception such as `std::bad_alloc` or any exception from the copy constructor of `Msg`. ||

Options for `Schedule`:

||`struct active::schedule::none` ||Does not schedule the object. ||
|| `struct active::schedule::own_thread` || Dedicates an OS thread for this object. ||
|| `struct active::schedule::thread_pool` || Uses `active::scheduler` to schedule this object. ||

Options for `Queueing`:

|| `struct active::queueing::direct_call` || Messages are executed immediately without a mutex. ||
|| `struct active::queueing::mutexed_call` || Messages are executed immediately, protected by a recursive mutex. ||
|| `template<typename Allocator=std::allocator<void>> struct active::queueing::shared` || Messages are queued as per normal AO semantics. ||
|| `template<typename Allocator=std::allocator<void>> struct active::queueing::separate` || Alternative implementation. ||
|| `template<typename Q> struct active::queueing::steal` || Directly executes the message handler if the object is idle. ||

Options for `Sharing`:

|| `struct active::sharing::disabled` || No explicit shared pointer support. ||
|| `template<typename T> struct active::sharinging::enabled` || Enhanced shared pointer support. `shared_from_this()` returns a pointer of type `std::shared_ptr<T>`. ||
 

Threading guarantees:
This class is completely thread-safe, except during construction and destruction, or except for `active::queueing::direct_call`. The message handlers themselves are run single-threaded, but cannot (should not!) be called directly.

== active::object ==

{{{
typedef object_impl<schedule::thread_pool, queueing::shared, sharing::disabled> object;
}}}

This implements the default AO type.

== active::shared == 
{{{
template<typename T>
struct shared : public object_impl<schedule::thread_pool, queueing::shared, sharing::enabled<T>>
{
    ...
};
}}}
This implements the default AO type for shared pointers.
== active::fast ==
{{{
typedef object_impl<schedule::thread_pool, queuing::steal<queueing::shared>, sharing::disabled> thread;
}}}

== active::thread ==
{{{
typedef object_impl<schedule::own_thread, queueing::shared, sharing::disabled> thread;
}}}

== active::shared_thread ==
{{{
template<typename T>
struct shared : public object_impl<schedule::own_thread, queueing::shared, sharing::enabled<T>>
{
   ...
};
}}}

== active::synchronous ==
{{{
typedef object_impl<schedule::none, queueing::mutexed_call, sharing::disabled> synchronous;
}}}

== active::direct ==
{{{
typedef object_impl<schedule::none, queueing::direct_call, sharing::disabled> direct;
}}}

== active::scheduler ==
Schedules the message processing on a collection of active objects.
{{{
class scheduler;
}}}

Methods:

|| `scheduler()` || ||
|| `scheduler(const scheduler&) = delete` || ||
|| `scheduler& operator=(const scheduler&) = delete` || ||
|| `~scheduler()` || Must not be called during `run()`. ||
|| `void run()` || Runs the scheduler in a single thread. Can be called concurrently from multiple threads. ||
|| `void run(int threads)` || Runs the scheduler using the specified number of threads. Must not be called concurrently from multiple threads. ||

== active::sink ==
{{{
template<typename T>
struct sink
{
    ACTIVE_IFACE(T);
};
}}}
Provides a pure virtual base class for accepting messages.

= Global variables =
== active::default_scheduler ==
{{{
extern scheduler default_scheduler;
}}}
The global scheduler, used by objects by default unless overridden by `object_impl::set_scheduler()`. Global variables are of course to be discouraged, and is only provided for convenience.

= Macros =

== ACTIVE_IFACE =
{{{
#define ACTIVE_IFACE( MSG ) ...
}}}
Defines a message handler as a virtual method. `MSG` must name a type.

== ACTIVE_METHOD ==
{{{
#define ACTIVE_METHOD( MSG ) ...
}}}
Declares or defines an active method (message handler) in a class. `MSG` must name a type.

== ACTIVE_IMPL ==

{{{
#define ACTIVE_IMPL( MSG ) ...
}}}
Defines an active method, usage is as follows:
{{{
void ClassName::ACTIVE_IMPL(MSG)
{
    ...
}
}}}

= Functions =

= active::run ==
{{{
void run(int threads=std::thread::hardware_concurrency());
}}}
Calls `default_scheduler.run(threads)`.