#summary Detailed description of cppao

= Header files=
|| Header file || Description || Definitions ||
|| `active/advanced.hpp` || Implements a more sophisticated AO type || [#active::advanced advanced] ||
|| `active/direct.hpp` || Non-mutexed objects. || [#active::direct direct] ||
|| `active/fast.hpp` || || `fast` ||
|| `active/object.hpp` || The main include file, which includes all of the basics. || [#ACTIVE_METHOD ACTIVE_METHOD], [#ACTIVE_IMPL ACTIVE_IMPL], [#ACTIVE_IFACE ACTIVE_IFACE], [#ACTIVE_TEMPLATE ACTIVE_TEMPLATE], `any_object`, [#active::default_scheduler default_scheduler], [#active::object object], [#active::object_impl object_impl], [#active::run run], [#active::sink sink] ||
|| `active/promise.hpp` || || [#active::promise promise] ||
|| `active/scheduler.hpp` || || [#active::scheduler scheduler] ||
|| `active/separate.hpp` || || [#active::separate separate] ||
|| `active/shared.hpp` || Additional support for shared pointers. || [#active::shared shared] ||
|| `active/synchronous.hpp` || || [#active::synchronous synchronous] ||
|| `active/thread.hpp` || Running AOs in a dedicated OS thread. || [#active::thread thread] ||

= Namespace =
All declarations are in the namespace `active`.

= Classes =
== active::object_impl ==
control various aspects of the implementation.
{{{
template<typename Schedule, typename Queueing, typename Sharing> class object_impl;
}}}
This class is the generic implementation type for all active objects. Template parameters are used to 

Types:

|| `queue_type` || `Queueing` ||
|| `schedule_type` || `Schedule` ||
|| `sharing_type` || `Sharing` ||
|| `scheduler_type` || Usually `active::scheduler` ||
|| `allocator_type` || `Queueing::allocator_type` ||
|| `size_type` || ||

Methods:

|| `object_impl(scheduler_type & p = default_scheduler, const allocator_type & alloc = allocator_type())` || Default constructor. Objects are scheduled by the global `default_scheduler` unless otherwise specified. ||
|| `object_impl(const object_impl&)` || Does a default copy, but does not copy any messages. ||
|| `object_impl & operator=(const object_impl&)` || Default copy operator, but does not copy any messages. ||
|| `~object_impl()` || Destroys the object; must not be called whilst there are unprocessed messages. ||
|| `void set_scheduler(scheduler_type & p)` || Change the scheduler. Must not be called after messages have been sent to the object. ||
|| `virtual void exception_handler()` || Called when an exception escapes from a message handler. This must not throw an exception. The default implementation is to write a message and continue, but can be overridden. ||
|| `allocator_type get_allocator() const` || Returns a copy of the allocator passed into the constructor. ||
|| `void operator()(const Msg&)` || Message handlers defined by `ACTIVE_IFACE` and `ACTIVE_METHOD` macros. This might throw an exception such as `std::bad_alloc` or any exception from the copy constructor of `Msg`. ||

Options for `Schedule`:

||`struct active::schedule::none` ||Does not schedule the object. ||
|| `struct active::schedule::own_thread` || Dedicates an OS thread for this object. ||
|| `struct active::schedule::thread_pool` || Uses `active::scheduler` to schedule this object. ||

Options for `Queueing`:

|| `struct active::queueing::direct_call` || Messages are executed immediately without a mutex. ||
|| `struct active::queueing::mutexed_call` || Messages are executed immediately, protected by a recursive mutex. ||
|| `template<typename Allocator=std::allocator<void>> struct active::queueing::shared` || Messages are queued as per normal AO semantics. ||
|| `template<typename Allocator=std::allocator<void>> struct active::queueing::separate` || Alternative implementation. ||
|| `template<typename Q> struct active::queueing::steal` || Directly executes the message handler if the object is idle. ||
|| `template<typename Allocator=std::allocator<void>> struct active::queueing::advanced` || A more sophisticated queueing implementation. ||

Options for `Sharing`:

|| `struct active::sharing::disabled` || No explicit shared pointer support. ||
|| `template<typename T> struct active::sharinging::enabled` || Enhanced shared pointer support. `shared_from_this()` returns a pointer of type `std::shared_ptr<T>`. ||
 

Threading guarantees:
This class is completely thread-safe, except during construction and destruction, or except for `active::queueing::direct_call`. The message handlers themselves are run single-threaded, but cannot (should not!) be called directly.

== active::object ==

{{{
typedef object_impl<...> object;
}}}

This implements the default AO type.

== active::shared == 
{{{
template<typename T, typename Base=object>
struct shared : public object_impl<Base>
{
    ...
    typedef object_impl<...> type;
    typedef std::shared_ptr<T> ptr;
};
}}}
This implements the default AO type for shared pointers.

== active::fast ==
{{{
typedef object_impl<...> fast;
}}}

== active::thread ==
{{{
typedef object_impl<...> thread;
}}}

== active::synchronous ==
{{{
typedef object_impl<...> synchronous;
}}}

== active::direct ==
{{{
typedef object_impl<...> direct;
}}}

== active::advanced ==
{{{
typedef object_impl<...> advanced;
}}}

Additional methods of this class:

|| size_type size() const || Returns the number of messages waiting.||
|| void clear () || Removes all pending messages. Protected method only callable from active methods. ||
|| void set_capacity(size_type) || Sets the new capacity (maximum number of queued messages. Attempts to exceed the capacity result in the exception `std::bad_alloc` || 

In addition there is the function

{{{
namespace active
{
    template<typename T> int priority(const T&)
    {
        return 0;
    }
}
}}}

which can be used to assign a priority to any message type (which may or may not depend on the contents as well as the type of the message). Note that the default priority is 0.

== active::scheduler ==
Schedules the message processing on a collection of active objects.
{{{
class scheduler;
}}}

Methods:

|| `scheduler()` || ||
|| `scheduler(const scheduler&) = delete` || ||
|| `scheduler& operator=(const scheduler&) = delete` || ||
|| `~scheduler()` || Must not be called during `run()`. ||
|| `void run()` || Runs the scheduler in a single thread. Can be called concurrently from multiple threads. ||
|| `void run(int threads)` || Runs the scheduler using the specified number of threads. Must not be called concurrently from multiple threads. ||
|| bool run_one() || Runs one AO, returns true if there is more work to do. ||

== active::run ==
Runs a scheduler in a thread pool. Note that this class is often used as a function.
{{{
class run;
}}}

Methods:

|| `run(int num_threads=std::thread::hardware_concurrency(), scheduler & sched=default_scheduler)` || Starts the thread pool and starts processing messages. ||
|| `~run()` || Waits for all messages to be processed and stops the thread pool. ||

== active::sink ==
{{{
template<typename T>
struct sink
{
    ACTIVE_IFACE(T);
};
}}}
Provides a pure virtual base class for accepting messages.

== active::promise ==
Provides a promise/future mechanism for returning results from AOs.
{{{
template<typename T> class promise : public direct, public sink<T>
{
    ...
};
}}}

Typenames:
|| value_type || T ||

Methods:
|| `promise()` || Default constructor. ||
|| `T get()` || Blocking call to retrieve the value. ||  

= Global variables =
== active::default_scheduler ==
{{{
extern scheduler default_scheduler;
}}}
The global scheduler, used by objects by default unless overridden by `object_impl::set_scheduler()`. Global variables are of course to be discouraged, and are only provided for convenience.

= Macros =

== ACTIVE_IFACE =
{{{
#define ACTIVE_IFACE( MSG ) ...
}}}
Defines a message handler as a virtual method. `MSG` must name a type.

== ACTIVE_METHOD ==
{{{
#define ACTIVE_METHOD( MSG ) ...
}}}
Declares or defines an active method (message handler) in a class. `MSG` must name a type.

== ACTIVE_TEMPLATE ==
{{{
#define ACTIVE_TEMPLATE( MSG ) ...
}}}
This class behaves like `ACTIVE_METHOD` but can be used in a templates class. Note that the type name `queue_type` must be defined prior to using this macro.

== ACTIVE_IMPL ==

{{{
#define ACTIVE_IMPL( MSG ) ...
}}}
Defines an active method, usage is as follows:
{{{
void ClassName::ACTIVE_IMPL(MSG)
{
    ...
}
}}}