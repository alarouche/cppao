#summary How to use cppao

= Introduction =

Active objects (AOs) are an established concurrent programming technique where objects communicate via messages rather than by direct method calls. This makes active objects thread-safe because they can only process one message at a time, whilst at the same time different AOs can run on different CPU cores and are guaranteed not to interfere with each other.

C++ Active Objects (cppao) is a library to make it simple to implement active objects in C++.

= Getting started =

See the [BuildInstructions build instructions] on how to download and install the cppao library.

= Hello active! =
The first example is
[http://code.google.com/p/cppao/source/browse/trunk/samples/hello_active.cpp hello_active.cpp]
{{{
#include <active/object.hpp>
#include <iostream>

class HelloActive : public active::object<HelloActive>
{
public:
        void active_method(const char * sender, const char * msg)
        {
                std::cout << sender << " says " << msg << "!\n";
        }
};

int main()
{
        HelloActive hello;
        hello("Bob", "hello");
        active::run();
}
}}}

Since this is the first example, let's go through it line by line:

{{{
#include <active/object.hpp>
}}}

This includes the header file, you need to do this.

{{{
#include <iostream>
}}}

This includes a system header file, which we'll need to output text.

{{{
class HelloActive : public active::object<HelloActive>
}}}

This line defines a new class, which inherits from `active::object`. `active::object` is supplied the name of your class so that it knows where to dispatch methods to.

{{{
        void active_method(const char * sender, const char * msg)
}}}
Defines a new active method, which in this case takes two arguments.
{{{
        {
                std::cout << sender << " says " << msg << "!\n";
        }
}}}
Implements the active method.

{{{
        HelloActive hello;
}}}

Create a new instance of the active object of type `HelloActive`.

{{{
        hello("Bob", "hello");
}}}
An asynchronous call to the object, which returns immediately but does not run until the scheduler tells it to. Active methods are queued and run one at a time.

Notice that we didn't call `active_method()` directly. That would be bad because it would executed immediately and potentially unsafely.  Ideally `active_method`s are private and have a line like `friend class active::object<HelloActive>;` in the derived class

{{{
        active::run();
}}}

Runs all active objects in a thread pool until there are no more messages.

= Ping pong! =

Our next example is almost as simple as the first:
[http://code.google.com/p/cppao/source/browse/trunk/samples/ping_pong.cpp ping_pong.cpp]
This just shows how active objects can implement several different active methods. Active methods are overloaded using different parameter types.

= Round Robin =

This example [http://code.google.com/p/cppao/source/browse/trunk/samples/round_robin.cpp round_robin.cpp] shows how multiple objects can interact. Here we have 1000 instances of the same class. 

{{{
#include <active/object.hpp>
#include <cstdio>

/* A slightly more sophisticated example.
 * In this case, each node punts a message to its next node in a loop.
 * To make things interesting, we add lots of messages concurrently.
 */

struct RoundRobin : public active::object<RoundRobin>
{
        RoundRobin * next;

        void active_method( int packet )
        {
                printf( "Received packed %d\n", packet );
                if( packet>0 ) (*next)(packet-1);
        }
};

int main()
{
        // Create 1000 nodes.
        const int Count=1000;
        RoundRobin nodes[Count];

        // Link them together
        for(int i=0; i<Count-1; ++i) nodes[i].next = nodes+i+1;
        nodes[Count-1].next=nodes;

        // Send each node a packet.
        for(int i=0; i<Count; ++i) nodes[i](10);

        active::run();
}
}}}

= Returning results =

Active method calls are non-blocking asynchronous calls, which do not return a result to the caller. This requires a redesign of your application.

One approach is to use a _future_, which is a fairly common solution to this problem, as follows:

{{{
    std::promise<int> value;
    add(1,2,value);
    int result = value.get_future().get();
}}}

This is actually quite a bad idea, because you are fundamentally muddling the synchronous and asynchronous paradigms. The active object you are calling from becomes blocked, the whole program can deadlock, and you are hogging an entire OS thread. There is nothing wrong with futures per se, but they are a different paradigm.

The biggest conceptual difficulty with active objects is actually designing your application. Because active methods are fire-and-forget, you can't return a result from them. Instead of _returning_ results, we should instead think about _forwarding_ results. You must design your application like a message-processing pipeline, where active objects are interlinked, and pass messages between each other.

So to ask how results are returned is to ask the wrong question. The question is really, how to interconnect objects?

The basic method of interconnection is shown in [http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result.cpp forward_result.cpp], where one AO passes the result to another as specified in the message itself. The tiny problem with this example is that the `ComplexComputation` class is bound to the `ComputationHandler` class. Ideally we would like to decouple the sender from the recipient, and this is achievable through pure virtual base classes. We can use `ACTIVE_IFACE` or `active::sink<>` to define an interface through which AOs communicate, as illustrated in [http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result_iface.cpp forward_result_iface.cpp] and [http://code.google.com/p/cppao/source/browse/trunk/samples/forward_result_sink.cpp forward_result_sink.cpp].

In this example, we implement a computation in the class `ComplexComputation`, which then forward its result to an object of type `active::sink<>`. The recipient is specified in the `ComplexComputation::computation` message itself.
{{{
#include <active/object.hpp>
#include <iostream>

class ComplexComputation : public active::object
{
public:
        struct computation
        {
                int a, b;
                active::sink<int> & handler;
        };
        
        ACTIVE_METHOD( computation ) const;      // Look we can even have const active methods
};

class ComputationHandler : public active::object, public active::sink<int>
{
public:
        typedef int result;
        
        ACTIVE_METHOD( result ) const
        {
                std::cout << "Result of computation = " << result << std::endl;
        }
};

void ComplexComputation::ACTIVE_IMPL( computation ) const
{
        computation.handler(computation.a + computation.b);
}

int main()
{
        ComputationHandler handler;
        ComplexComputation cc;
        ComplexComputation::computation comp = { 1,2,handler };
        cc(comp);
        active::run();
}
}}}
The recipient of the result is implemented in class `ComputationHandler`, which implements the `ACTIVE_METHOD` to handle the result. In this way, the computation and the handler are completely decoupled.

Also observe that we can implement active methods outside of the class (thankfully), using the `ACTIVE_IMPL` macro, and we can even make active methods const.

Finally, and because the literature says we must, we can also put results into _promise_, as shown in [http://code.google.com/p/cppao/source/browse/trunk/samples/future.cpp future.cpp]. The `active::promise<>` class is an active object which can also be accessed from synchronous code. Personally I would design the entire application using active objects so as to not mix paradigms.

= Lambda methods =

In C++11, one has the opportunity to implement active methods as lambdas. Code for this looks as follows [http://code.google.com/p/cppao/source/browse/trunk/samples/hello_active_lambda.cpp hello_active_lambda.cpp]:

{{{
#include <active/object.hpp>
#include <iostream>

class HelloActive : public active::object<HelloActive>
{
public: 
        void greet(const char * msg)
        {
                active_fn([=]{ std::cout << msg << std::endl; });
        }
};

int main()
{
        HelloActive hello;
        hello.greet("Hello, world!");
        active::run();
}
}}}
In this case, the active method (which can now have a sensible name) enqueues the real implementation using a call to `active_fn`.

Note that one could also achieve something similar in C++03 using `boost::bind`.

It is a matter of personal taste as to which approach is preferred.

= Exception handling =

In the same way that return values can't be delivered to the point of calling, so exceptions can't be propagated to the caller either. So where to deliver the exception? 

Instead they are delivered to the `exception_handler()` method (which is not an active method), which can rethrow, catch and handle the exception. If `exception_handler()` emits an exception, then the application terminates. 

Of course, if an active method wants to do something different, then it must implement `try...catch` itself.

= Using shared pointers =

The examples so far have relied on raw C-style pointers, mainly for simplicity. This has the obvious drawback that you might end up with dangling pointers, or that objects are destroyed whilst there are still messages on their queue.

You could also use references but the same problem arises.

To solve this, the class `active::shared<>` can be used as a base class for your AO, which will then safely enqueue messages to the shared object, and be guaranteed that the object will only be destroyed after all messages have been processed.

The sample [http://code.google.com/p/cppao/source/browse/trunk/samples/object_types.cpp object_types.cpp] demonstrates this.

{{{
#include <active/shared.hpp>

struct shared_object : public active::shared<shared_object>
{
        ACTIVE_METHOD(greeting) { std::cout << "Shared object says " << greeting << std::endl; }
};
}}}

= Object types =

There are actually a number of base classes you could choose for your active objects, each with different characteristics.

|| Base class || Header file || Description ||
|| `active::object` || `active/object.hpp` || The basic, non-blocking AO. ||
|| `active::shared<>` || `active/shared.hpp` || Prevents premature object destruction using smart pointers, `std::shared_ptr<>`. ||
|| `active::fast` || `active/fast.hpp` || Processes the message in the calling thread if the object is idle. This is often faster but can fail to exploit the hardware fully. ||
|| `active::thread` || `active/thread.hpp` || Dedicates an OS thread to this AO. ||
|| `active::advanced` || `active/advanced.hpp` || A more feature-rich AO which supports message prioritization, query queue size, clear queue and limit queue size. ||
|| `active::synchronous` || `active/synchronous.hpp` || Always processes message in the calling thread, but guarded by a mutex. Not a true AO. ||
|| `active::direct` || `active/direct.hpp` || An unguarded AO which is not thread-safe but can be used if the class is entirely thread-safe or has no mutable state. ||

See FineTuning for further details, and the sample [http://code.google.com/p/cppao/source/browse/trunk/samples/object_types.cpp object_types.cpp] shows off the different implementations.

= Staying safe =
Active objects guarantee that your program will be thread-safe, if you follow these guidelines: 

  * Communicate only via messages:
    * Make all mutable class-members private.
    * Make all non-active methods private.
  * Ensure messages are thread-safe:
    * Restrict messages to value-types and pointers to AOs.
    * Use move semantics (`std::move()` etc.) when passing large arrays between objects.
    * Avoid (shared) pointers to anything else, unless they are `unique()`.
    * Avoid weak pointers in messages, as they aren't needed.
  * Ensure all pointers and references are valid: use smart pointers.
  * Avoid blocking calls (e.g. network, `std::future<>::get()`), unless using `active::thread`.

Deadlock cannot occur; what happens is that your program runs out of messages and exits. 

If you break these guidelines, then your code may well still be correct, but you will forever have the worry that it may not be....

= Where next? =
Now you have the tools, it is time to apply them! Check out the [Samples] and the [Reference]. You can also read FineTuning if you want to compose your own AO.