#summary How to use cppao

= Introduction =

Active objects are a concurrent programming technique where objects communicate via messages rather than by direct method calls. This makes active objects thread-safe because they can only process one message at a time, and provided that the message is a simple value type, there can be no problems with concurrent access.

C++ Active Objects (cppao) is a small library to make it relatively simple to implement active objects in C++.

= Getting started =

You need to check out all of the source code, and add the files "active_object.cpp" and "active_object.hpp" to a new project. There is a CMake file and a Visual Studio solution file to get you started. You may need to enable C++11 in your toolchain.

= Hello active! =
The first example is
[http://code.google.com/p/cppao/source/browse/trunk/samples/hello_active.cpp hello_active.cpp]
{{{
#include <active_object.hpp>
#include <iostream>

class HelloActive : public active::object
{
public:
        struct Greet { const char * message; };
        
        ACTIVE_METHOD( Greet )
        {
                std::cout << Greet.message << std::endl;
        }
};

int main()
{
        HelloActive hello;
        HelloActive::Greet message = { "Hello, world!" };
        hello(message);
        hello.run();
        return 0;
}
}}}

Since this is the first example, let's go through it line by line:

{{{
#include <active_object.hpp>
}}}

This includes the header file, you need to do this.

{{{
#include <iostream>
}}}

This includes a system header file, which we'll need to output text.

{{{
class HelloActive : public active::object
}}}

This line defines a new class. All active object classes inherit from active::object, or active::shared<> (more on active::shared<> later)...

{{{
        struct Greet { const char * message; };
}}}

Defines a new message which we can send to our active object. A message can be any data type.

{{{
        ACTIVE_METHOD( Greet )
}}}

Defines a new active method (=message handler). This active method handles messages of type "Greet".

{{{
        {
                std::cout << Greet.message << std::endl;
        }
}}}

Implements our message handler, which just displays the text.

{{{
        HelloActive hello;
}}}

Create a new active object of type "HelloActive".

{{{
        HelloActive::Greet message = { "Hello, world!" };
}}}

Create a new message to send to the object.

{{{
        hello(message);
}}}

Pass the message to the object. The object will receive the message at some point in the future, and in fact will just sit in the message queue of the object until it is run. Messages are passed by value (copied) into the message queue, so once it's sent, the original message can be destroyed.

Explicitly run the message handler of the object until there are no more messages left, at which point it exits.

{{{
        hello.run();
}}}

= Ping pong! =

Our next example is almost as simple as the first:
[http://code.google.com/p/cppao/source/browse/trunk/samples/ping_pong.cpp ping_pong.cpp]
This just shows how active objects can implement several different messages.

= Round Robin =

This example [http://code.google.com/p/cppao/source/browse/trunk/samples/round_robin.cpp round_robin.cpp] shows how multiple objects can interact. Here we have 1000 instances of the same class. We don't run the _RoundRobin::run()_ method in 1000 different threads (though I guess we could), but instead we call the function _active::run()_ which runs all of our objects in a thread pool. This is generally more efficient than creating one OS thread per active object.

{{{
#include <active_object.hpp>
#include <iostream>

struct RoundRobin : public active::object
{
        typedef int packet;
        
        RoundRobin * next;
        
        ACTIVE_METHOD( packet )
        {
                std::cout << "Received packet " << packet << "\n";
                if( packet>0 ) (*next)(packet-1);
        }
};

int main()
{       
        // Create 1000 nodes.
        const int Count=1000;
        RoundRobin nodes[Count];
        
        // Link them together
        for(int i=0; i<Count-1; ++i) nodes[i].next = nodes+i+1;
        nodes[Count-1].next=nodes;
        
        // Send each node a packet.
        for(int i=0; i<Count; ++i) nodes[i](10);
                
        // Run all objects in 16 threads.
        active::run(16);
        return 0;
}
}}}

= Returning results =

Our next examples (return_result.cpp, forward_result.cpp, future.cpp, forward_result_iface.cpp, forward_result_sink.cpp) show different approaches for returning results from an active object.

The main problem is of course that the result of an active method cannot be returned to the point of calling.

My favoured approach is to use a "message sink", which is an active object which receives the result of the calculation. The message sink (provided by active::sink<>) provides a pure virtual base class. Your receiving object must then implement this method in order to receive the result.

In this example, we implement a computation in the class ComplexComputation, which then forward its result to an object of type active::sink&lt;int&gt;. The recipient is specified in the ComplexComputation::computation message itself.
{{{
#include <active_object.hpp>
#include <iostream>

class ComplexComputation : public active::object
{
public:
        struct computation
        {
                int a, b;
                active::sink<int> * handler;
        };
        
        ACTIVE_METHOD( computation ) const;      // Look we can even have const active methods
};

class ComputationHandler : public active::object, public active::sink<int>
{
public:
        typedef int result;
        
        ACTIVE_METHOD( result ) const
        {
                std::cout << "Result of computation = " << result << std::endl;
        }
};

void ComplexComputation::ACTIVE_IMPL( computation ) const
{
        (*computation.handler)(computation.a + computation.b);
}

int main()
{
        ComputationHandler handler;
        ComplexComputation cc;
        ComplexComputation::computation comp = { 1,2,&handler };
        cc(comp);
        active::run();
        return 0;
}
}}}
The recipient of the result is implemented in class ComputationHandler, which implements the ACTIVE_METHOD to handle the result. In this way, the computation and the handler are completely decoupled.

Also observe that we can implement active methods outside of the class (thankfully), using the ACTIVE_IMPL macro, and we can even make active methods const.


= Exception handling =

In the same way that return values can't be delivered to the point of calling, so exceptions can't be propagated to the caller either. So where to deliver the exception? 

The answer is to deliver them to the "exception_handler()" method (which is not an active method), which can rethrow, catch and handle the exception. If exception_handler emits an exception, then application terminates. 

= Using shared pointers =

The examples so far have relied on raw C-style pointers, mainly for simplicity. You may want to use something better, and since this is C+11, _std::shared_ptr<>_.

A potential problem occurs with message handling. If an AO still has unprocessed messages on destruction, then we have a problem. CPPAO terminates the application, since destructors mustn't throw exceptions.

With shared pointers however, we can safely enqueue messages to the shared object, and be guaranteed that the object will only be destroyed when all messages have been processed.

An example which illustrates this is echo_server in the [Samples].

= What next? =
Now you have the tools, it is time to apply them! Check out the [Samples], and you may even need the [Reference].

I hope you found this entertaining, and perhaps even useful!